[[events.application-module-listener]]
= üßë‚Äçüíª Switching to `@ApplicationModuleListener`

[[events.application-module-listener.objectives]]
== üéØ Objectives

In this section you will learn how‚Ä¶

* ‚Ä¶ to switch the module interaction to an asynchronous model by using the `@ApplicationEventListener` annotation
* ‚Ä¶ that switch changes the consistency model of the interaction
* ‚Ä¶ to guard the asynchronous interaction against listener failures using the Event Publication Registry

[[events.application-module-listener.steps]]
== üë£ Changing the listener execution model


. Replace the `@EventListener` annotation in both `InventoryManagement` and `EmailSender` with `@ApplicationEventListener`.

. Re-run the test.

Examine the log output.

[source, text]
----
‚Ä¶ main : Started OrderManagementIntegrationTests in 1.464 seconds (process running for 2.171)
‚Ä¶ main : Creating new transaction with name [com.example.app.order.OrderManagement.complete]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
‚Ä¶ main : Opened new EntityManager [SessionImpl(1977568029<open>)] for JPA transaction
‚Ä¶ main : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@3bf41cd0]
‚Ä¶ main : Found thread-bound EntityManager [SessionImpl(1977568029<open>)] for JPA transaction
‚Ä¶ main : Participating in existing transaction
‚Ä¶ main : Finish order completion.
‚Ä¶ main : Initiating transaction commit
‚Ä¶ main : Committing JPA transaction on EntityManager [SessionImpl(1977568029<open>)]

‚Ä¶ main : Found thread-bound EntityManager [SessionImpl(1977568029<open>)] for JPA transaction
‚Ä¶ main : Suspending current transaction, creating new transaction with name [com.example.app.inventory.Inventory.on]
‚Ä¶ main : Opened new EntityManager [SessionImpl(1074053050<open>)] for JPA transaction
‚Ä¶ main : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@c19bb2a]
‚Ä¶ main : Found thread-bound EntityManager [SessionImpl(1074053050<open>)] for JPA transaction
‚Ä¶ main : Participating in existing transaction
‚Ä¶ main : Found thread-bound EntityManager [SessionImpl(1074053050<open>)] for JPA transaction
‚Ä¶ main : Participating in existing transaction
‚Ä¶ main : Updating stock for order 218cca0f-c89c-4342-a7af-a25c4c5740ee.
‚Ä¶ main : Initiating transaction commit
‚Ä¶ main : Committing JPA transaction on EntityManager [SessionImpl(1074053050<open>)]
‚Ä¶ main : Closing JPA EntityManager [SessionImpl(1074053050<open>)] after transaction

‚Ä¶ main : Resuming suspended transaction after completion of inner transaction
‚Ä¶ main : Found thread-bound EntityManager [SessionImpl(1977568029<open>)] for JPA transaction
‚Ä¶ main : Suspending current transaction, creating new transaction with name [com.example.app.order.EmailSender.on]
‚Ä¶ main : Opened new EntityManager [SessionImpl(1394284408<open>)] for JPA transaction
‚Ä¶ main : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@ecfff32]
‚Ä¶ main : Sending email for order 218cca0f-c89c-4342-a7af-a25c4c5740ee.
‚Ä¶ main : Email sent for order 218cca0f-c89c-4342-a7af-a25c4c5740ee.
‚Ä¶ main : Initiating transaction commit
‚Ä¶ main : Committing JPA transaction on EntityManager [SessionImpl(1394284408<open>)]
‚Ä¶ main : Closing JPA EntityManager [SessionImpl(1394284408<open>)] after transaction

‚Ä¶ main : Resuming suspended transaction after completion of inner transaction
‚Ä¶ main : Closing JPA EntityManager [SessionImpl(1977568029<open>)] after transaction
----

Our transactional execution arrangement got slightly more complicated.
`OrderManagement.complete(‚Ä¶)` publishes events and they get registered for submission on transaction commit.
The business method succeeds and the original transaction gets committed.
During the transaction cleanup phase, the listener declared in `InventoryManagement` is triggered due to the implicit `@TransactionalEventListener`.
A new transaction is created as `@ApplicationModuleListener` is meta-annotated with `@Transactional(propagation = REQUIRES_NEW)`.
The original transaction however is suspended, but resources are kept alive (see the `EntityManager` instance 1977568029 and thus the connection backing it).
Also, the listener is executed on the same (`main`) thread.
The `@Async` annotation does not seem to be considered yet.
The same applies to the second listener to send out emails.
The original business transaction (`EntityManager` instance 1977568029) is closed eventually.

. To get the asynchronous execution working, add `@EnableAsync` on the main application class:
ifndef::educates[]
+
[source, java]
----
@EnableAsync // <- add this
@SpringBootApplication
public class Application { /* ‚Ä¶ */ }
----
endif::[]

. As we expect our listener to be executed on a separate thread, the call to `OrderManagement.complete()` will immediately return.
To make sure that the test doesn't quit before the listener has completed, let us add a `Thread.sleep()` to it for now.
We will improve on that later.
ifndef::educates[]
+
[source, java]
----
@SpringBootTest
class OrderManagementIntegrationTests {

	@Test
	void publishesEventOnCompletion() throws InterruptedException {

		orders.complete(new Order());

		Thread.sleep(2000); // <- add this and that ^^
	}
}
----
endif::[]

. Re-run `OrderManagementIntegrationTests`.

Examine the log output.
Notice that the invocation of our listener updating the inventory has been moved to a separate thread as we can see from the `task-1` thread name in the log output and gets an dedicated transaction started (1062114679).
The same for the thread executing the email sending.
[source, text]
----
‚Ä¶   main : Started OrderManagementIntegrationTests in 1.505 seconds (process running for 2.177)
‚Ä¶   main : Creating new transaction with name [com.example.app.order.OrderManagement.complete]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
‚Ä¶   main : Opened new EntityManager [SessionImpl(1604949791<open>)] for JPA transaction
‚Ä¶   main : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@377cbdae]
‚Ä¶   main : Found thread-bound EntityManager [SessionImpl(1604949791<open>)] for JPA transaction
‚Ä¶   main : Participating in existing transaction
‚Ä¶   main : Finish order completion.
‚Ä¶   main : Initiating transaction commit
‚Ä¶   main : Committing JPA transaction on EntityManager [SessionImpl(1604949791<open>)]

‚Ä¶ task-1 : Creating new transaction with name [com.example.app.inventory.Inventory.on]: PROPAGATION_REQUIRES_NEW,ISOLATION_DEFAULT
‚Ä¶ task-1 : Opened new EntityManager [SessionImpl(1062114679<open>)] for JPA transaction
‚Ä¶ task-1 : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@31896cee]
‚Ä¶ task-1 : Found thread-bound EntityManager [SessionImpl(1062114679<open>)] for JPA transaction
‚Ä¶ task-1 : Participating in existing transaction
‚Ä¶ task-2 : Creating new transaction with name [com.example.app.order.EmailSender.on]: PROPAGATION_REQUIRES_NEW,ISOLATION_DEFAULT
‚Ä¶   main : Closing JPA EntityManager [SessionImpl(1604949791<open>)] after transaction
‚Ä¶ task-2 : Opened new EntityManager [SessionImpl(1942841355<open>)] for JPA transaction
‚Ä¶ task-2 : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@7d0a8802]
‚Ä¶ task-2 : Sending email for order 8fe72caf-3338-422d-b905-f017208839ba.
‚Ä¶ task-1 : Found thread-bound EntityManager [SessionImpl(1062114679<open>)] for JPA transaction
‚Ä¶ task-1 : Participating in existing transaction
‚Ä¶ task-1 : Updating stock for order 8fe72caf-3338-422d-b905-f017208839ba.
‚Ä¶ task-1 : Initiating transaction commit
‚Ä¶ task-1 : Committing JPA transaction on EntityManager [SessionImpl(1062114679<open>)]
‚Ä¶ task-1 : Closing JPA EntityManager [SessionImpl(1062114679<open>)] after transaction
‚Ä¶ task-2 : Email sent for order 8fe72caf-3338-422d-b905-f017208839ba.
‚Ä¶ task-2 : Initiating transaction commit
‚Ä¶ task-2 : Committing JPA transaction on EntityManager [SessionImpl(1942841355<open>)]
‚Ä¶ task-2 : Closing JPA EntityManager [SessionImpl(1942841355<open>)] after transaction
----

The primary effect of that is that the original transaction does not need to be suspended anymore as the transaction created for the listener runs without an existing transaction in its execution context.
This also means that the resources acquired by the original transaction can be freed early as evident from the interleaved log statement from the `main` thread.


. To see how this arrangement reacts to the original business method failing eventually, throw a `RuntimeException` at the very end of it.
ifndef::educates[]
+
[source, java]
----
public class OrderManagement {

	public void complete(Order order) {

		orders.save(order.complete());

		events.publishEvent(new OrderCompleted(order.getId()));

		log.info("Finish order completion.");

		throw new RuntimeException(); // <- add this
	}
}
----
endif::[]

. Re-run

Examine the log output.
Note how the failed execution leads to a transaction rollback and the listeners _not_ being invoked, despite the event having been published.
In other words, this scenario does not suffer from the premature email publication we have seen in <<events.integration.a-failing-listener>>.
[source, text]
----
‚Ä¶ main : Started OrderManagementIntegrationTests in 1.494 seconds (process running for 2.258)
‚Ä¶ main : Creating new transaction with name [com.example.app.order.OrderManagement.complete]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
‚Ä¶ main : Opened new EntityManager [SessionImpl(923439967<open>)] for JPA transaction
‚Ä¶ main : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@6cb417fc]
‚Ä¶ main : Found thread-bound EntityManager [SessionImpl(923439967<open>)] for JPA transaction
‚Ä¶ main : Participating in existing transaction
‚Ä¶ main : Finish order completion.
‚Ä¶ main : Initiating transaction rollback
‚Ä¶ main : Rolling back JPA transaction on EntityManager [SessionImpl(923439967<open>)]
‚Ä¶ main : Closing JPA EntityManager [SessionImpl(923439967<open>)] after transaction
----

[[events.application-module-listener.summary]]
== üí° Summary

We have switched to an integration mode in which the attached functionality is executed separately from the original unit of work.
This allows the seamless integration of such functionality in a way that it does not negatively affect the primary use case.
However, there are a couple of things to consider:

* As the listeners are executed asynchronously waiting for the side effects to manifest requires low-level thread handling.
This is something that could be nicer.
* The asynchronous execution implies the question of what happens if the event listener fails.
* Having to add `@EnableAsync` manually to make sure the listeners really get executed asynchronously feels a little cumbersome, too.

