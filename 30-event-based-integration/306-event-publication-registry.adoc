[[events.event-publication-registry]]
= üßë‚Äçüíª Event Publication Registry

To prevent event publications from being lost when listeners fail, Spring Modulith provides integration with Spring's application event bus.
It tracks the publications and decorates listeners to mark successfully handled event publications as completed.

[[events.event-publication-registry.objectives]]
== üéØ Objectives

You will learn‚Ä¶

* ‚Ä¶ how to make use of Spring Modulith's Event Publication Registry to keep track of outstanding event publications.
* ‚Ä¶ how that in place prevents event publications from getting lost in case of listener failures.

[[events.event-publication-registry.steps]]
== üë£ Add Spring Modulith's Event Publication Registry

. To make use of the Event Publication Registry add the Spring Modulith JPA starter to the `pom.xml`.
ifndef::educates[]
+
[source, xml]
----
<dependency>
	<groupId>org.springframework.modulith</groupId>
	<artifactId>spring-modulith-starter-jpa</artifactId>
</dependency>
----
endif::[]
The starter pulls in the general registry infrastructure and Spring Boot auto-configuration to automatically hook into Spring's `ApplicationEventMulticaster` to keep track of the publications and decorate transactional event listeners to mark the publications as completed on listener success.


. To see this working, simply re-run `OrderManagementIntegrationTests.completesOrder()`.

Examine the log output.
Note how, during the execution of the primary business method, the publication of the event triggers the registration of event publications with the registry.
As both listeners complete successfully, the publication is marked completed on the corresponding threads.
The test concludes by reporting that no publications are outstanding.
[source, text]
----
‚Ä¶     main : Started OrderManagementIntegrationTests in 1.911 seconds (process running for 2.648)
‚Ä¶     main : Registering publication of com.example.app.order.OrderCompleted for com.example.app.inventory.Inventory.on(com.example.app.order.OrderCompleted).
‚Ä¶     main : Registering publication of com.example.app.order.OrderCompleted for com.example.app.order.EmailSender.on(com.example.app.order.OrderCompleted).
‚Ä¶     main : Finish order completion.
‚Ä¶   task-2 : Sending email for order 1f1221e4-c748-43b4-a627-6556b1132b08.
‚Ä¶   task-1 : Updating stock for order 1f1221e4-c748-43b4-a627-6556b1132b08.
‚Ä¶   task-1 : Marking publication of event com.example.app.order.OrderCompleted to listener com.example.app.inventory.Inventory.on(com.example.app.order.OrderCompleted) completed.
‚Ä¶   task-2 : Email sent for order 1f1221e4-c748-43b4-a627-6556b1132b08.
‚Ä¶   task-2 : Marking publication of event com.example.app.order.OrderCompleted to listener com.example.app.order.EmailSender.on(com.example.app.order.OrderCompleted) completed.
‚Ä¶ downHook : No publications outstanding!
----

. Tweak the `Inventory` to fail during the processing of the order by re-adding the `RuntimeException`.
ifndef::educates[]
+
[source, java]
----
public class Inventory {

	public void updateStockFor(Order order) {

		log.info("Updating stock for order {}.", order.getId());

		throw new RuntimeException(); // <- add this
	}
}
----
endif::[]

. Re-run the integration tests.

Examine the log output.
Notice that the publications get registered as before, the `Inventory` listener fails as can be seen by the reported exception stack trace leaving the publication uncompleted.
This is also reported in the eventual shutdown of the application context.

[source, text]
----
‚Ä¶     main : Started OrderManagementIntegrationTests in 1.859 seconds (process running for 2.576)
‚Ä¶     main : Registering publication of com.example.app.order.OrderCompleted for com.example.app.inventory.Inventory.on(com.example.app.order.OrderCompleted).
‚Ä¶     main : Registering publication of com.example.app.order.OrderCompleted for com.example.app.order.EmailSender.on(com.example.app.order.OrderCompleted).
‚Ä¶     main : Finish order completion.
‚Ä¶   task-2 : Sending email for order 6dc323ab-926e-42f7-9a85-3614c4cb9888.
‚Ä¶   task-1 : Updating stock for order 6dc323ab-926e-42f7-9a85-3614c4cb9888.
‚Ä¶   task-1 : Invocation of listener void com.example.app.inventory.Inventory.on(com.example.app.order.OrderCompleted) failed. Leaving event publication uncompleted.

java.lang.RuntimeException: null
	at com.example.app.inventory.Inventory.updateStockFor(Inventory.java:49)
	at com.example.app.inventory.Inventory.on(Inventory.java:42)
	‚Ä¶

‚Ä¶   task-2 : Email sent for order 6dc323ab-926e-42f7-9a85-3614c4cb9888.
‚Ä¶   task-2 : Marking publication of event com.example.app.order.OrderCompleted to listener com.example.app.order.EmailSender.on(com.example.app.order.OrderCompleted) completed.
‚Ä¶ downHook : Shutting down with the following publications left unfinished:
‚Ä¶ downHook : ‚îî‚îÄ com.example.app.order.OrderCompleted - com.example.app.inventory.Inventory.on(com.example.app.order.OrderCompleted)
----

[[events.event-publication-registry.remove-at-enable-async]]
== üë£ Remove obsolete `@EnableAsync` annotation

Declaring the Spring Modulith JPA starter brought in the `spring-modulith-events-core` artifact.
This not only contains the Spring Boot configuration to enable the Event Publication Registry, it also makes sure that the support for asynchronous method invocations is enabled automatically.
Thus, we can remove the `@EnableAsync` annotation we had explicitly declared on our application class in <<events.application-module-listener.steps>>.


. Open up `Application.java` and remove the `@EnableAsync` annotation from the class declaration.
ifndef::educates[]
+
[source, java]
----
@EnableAsync // <- remove this
@SpringBootApplication
public class Application { /* ‚Ä¶ */ }
----
endif::[]

[[events.event-publication-registry.summary]]
== üí° Summary

