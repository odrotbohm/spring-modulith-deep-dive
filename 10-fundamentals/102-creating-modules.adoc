[[fundamentals.creating-modules]]
= 🧑‍💻 Creating Application Modules
:tabsize: 2
:source: complete/src/main/java/com/example/app
:test-source: complete/src/test/java/com/example/app

[[fundamentals.creating-modules.objectives]]
== 🎯 Objectives

You'll learn how to…

* … create an application module within the application.
* … bootstrap `ApplicationModules`.
* … inspect the application module model on the command line.

[[fundamentals.creating-modules.preparations]]
== 👣 Preparations

Now that you know that Spring Modulith specifically adds libraries in the test scope, create a test class in the application's root package in `src/test/java` named `ApplicationModularityTests`.

ifndef::educates[]
[source, java]
----
package com.example.app;

class ApplicationModularityTests {
}
----
endif::[]

ifdef::educates[]
[source, terminal:execute]
----
command: mkdir -p src/test/java/com/example/app
----

[source, editor:append-lines-to-file]
----
file: ~/exercises/src/test/java/com/example/app/ApplicationModularityTests.java
text: |
	package com.example.app;

	class ApplicationModularityTests {
	}
----
endif::[]

Within that class, create a test case to derive the application's module model.
Create a new instance of `ApplicationModules` pointing to the root Spring Boot application class.
Print the result to the console.

ifndef::educates[]
[source, java]
----
@Test
void bootstrapsApplicationModules() {

	var modules = ApplicationModules.of(Application.class);

	System.out.println(modules);
}
----
endif::[]

ifdef::educates[]
[source, editor:select-matching-text]
----
file: ~/exercises/src/test/java/com/example/app/ApplicationModularityTests.java
text: "class ApplicationModularityTests {"
before: 0
after: 1
----

[source, editor:replace-text-selection]
----
file: ~/exercises/src/test/java/com/example/app/ApplicationModularityTests.java
text: |

	import org.junit.jupiter.api.Test;
	import org.springframework.modulith.core.ApplicationModules;

	class ApplicationModularityTests {

		@Test
		void bootstrapsApplicationModules() {

			var modules = ApplicationModules.of(Application.class);

			System.out.println(modules);
		}
	}
----
endif::[]

Execute the test.

ifdef::educates[]
[source, terminal:execute]
----
command: mvnw test
----
endif::[]

Notice that the output is currently empty.

[source, bash]
----
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running com.example.app.ApplicationModularityTests
… [main] INFO com.tngtech.archunit.core.PluginLoader -- Detected Java version 17.0.7
----

[[fundamentals.creating-modules.adding-a-module]]
== 👣 Adding a Module

Create a package `order`.

ifdef::educates[]
[source, terminal:execute]
----
command: mkdir -p src/main/java/com/example/app/order
----
endif::[]

Add a public type `OrderManagement` in that package.

ifdef::educates[]
[source, editor:append-lines-to-file]
----
file: ~/exercises/src/main/java/com/example/app/order/OrderManagement.java
text: |
	package com.example.app.order;

	import org.springframework.stereotype.Component;

	@Component
	public class OrderManagement {}
----
endif::[]

Re-run the test.

ifdef::educates[]
[source, terminal:execute]
----
command: mvnw test
----
endif::[]

This time, an application module named `Order` is listed, and `OrderManagement`  is labeled as a public component (+).

[source, bash]
----
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running com.example.app.ApplicationModularityTests
… [main] INFO com.tngtech.archunit.core.PluginLoader -- Detected Java version 17.0.7
# Order
> Logical name: order
> Base package: com.example.app.order
> Direct module dependencies: none
> Spring beans:
  + ….OrderManagement
----

[[fundamentals.creating-modules.further-ideas]]
== 💡 Further ideas
* What happens if you add sibling packages to `order` containing Spring bean classes in them?
* How does changing the visibility modifier of the types in the packages change the test output?
* How does the test output change if you introduce a dependency between components in different modules?

