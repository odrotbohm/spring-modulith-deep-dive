[[module-design.control-visibility]]
= üßë‚Äçüíª Using Application Modules to control visibility

ifdef::educates[]
[source, terminal:execute-all]
----
command: cd ~/exercises && clear
autostart: true
hidden: true
----
[source, dashboard:reload-dashboard]
----
name: Editor
autostart: true
hidden: true
----
endif::[]

[[module-design.control-visibility.objectives]]
== üéØ Objectives

You'll learn how to‚Ä¶

* ‚Ä¶ add components and events to the module and control their visibility
* ‚Ä¶ verify foreign application modules cannot access internal components

[[module-design.control-visibility.package-protected-types]]
== üë£ Hiding application module internals by using the package scope

. Add an `OrderRepository` class in default scope to the `order` package

ifndef::educates[]
+
[source, java]
----
import org.springframework.stereotype.Repository;

@Repository
class OrderRepository {}
----
endif::[]

. In `OrderManagement`, create a Spring bean reference to the new `OrderRepository` class you just created.

ifndef::educates[]
+
[source, java]
----
include::{source}/order/OrderManagement.java[tags=class]
----
endif::[]

. Run the `ApplicationModularityTests`.

ifdef::educates[]
[source, section:begin]
----
title: "Expand for clickable instructions"
----
[source, editor:append-lines-to-file]
----
title: "Create OrderRepository"
file: ~/exercises/src/main/java/com/example/app/order/OrderRepository.java
text: |
	package com.example.app.order;

	import org.springframework.stereotype.Repository;

	@Repository
	class OrderRepository {}
----
[source, editor:select-matching-text]
----
title: "Add a reference to OrderRepository in OrderManagement"
file: ~/exercises/src/main/java/com/example/app/order/OrderManagement.java
text: "public class OrderManagement {}"
before: 2
after: 0
cascade: true
description: |
	import lombok.RequiredArgsConstructor;

	@Component
	@RequiredArgsConstructor
	public class OrderManagement {

		private final OrderRepository repository;
	}
----
[source, editor:replace-text-selection]
----
hidden: true
file: ~/exercises/src/main/java/com/example/app/order/OrderManagement.java
text: |
	import lombok.RequiredArgsConstructor;

	@Component
	@RequiredArgsConstructor
	public class OrderManagement {

		private final OrderRepository repository;
	}
----
[source, terminal:execute]
----
title: ‚ÄúRun test‚Äù
command: mvnw test
----
[source, section:end]
----
----
endif::[]

Examine the output.
`OrderManagement` is public and is labeled with `+`.
In contrast, `OrderRepository` is identified as an *internal* module component and labeled accordingly with `o`.
[source, text]
----
‚Ä¶
# Order
> Logical name: order
> Base package: com.example.app.order
> Direct module dependencies: none
> Spring beans:
  + ‚Ä¶.OrderManagement
  o ‚Ä¶.OrderRepository
----
To highlight the impact of Java visibility modifiers‚Äî`public`, `default/package-private`, etc‚Äîon the accessibility of classes between packages (aka between modules), try adding a reference to `OrderRepository` in `ApplicationModularityTests` and see how the compiler responds.
ifdef::educates[]
[source, section:begin]
----
title: "Expand for clickable instructions"
----
[source, editor:select-matching-text]
----
title: "Add reference to OrderRepository in ApplicationModularityTests"
file: ~/exercises/src/test/java/com/example/app/ApplicationModularityTests.java
text: "class ApplicationModularityTests {"
before: 0
after: 0
cascade: true
description: |
	import com.example.app.order.OrderRepository;

	class ApplicationModularityTests {

		OrderRepository orderRepository;
----
[source, editor:replace-text-selection]
----
hidden: true
file: ~/exercises/src/test/java/com/example/app/ApplicationModularityTests.java
text: |
	import com.example.app.order.OrderRepository;

	class ApplicationModularityTests {

		OrderRepository orderRepository;
----
[source, terminal:execute]
----
title: ‚ÄúRun test‚Äù
command: mvnw test
----
[source, section:end]
----
----
endif::[]

You should see a compilation error since `OrderRepository` can only be accessed from within the same package.
[source, text]
----
[INFO] -------------------------------------------------------------
[ERROR] COMPILATION ERROR :
[INFO] -------------------------------------------------------------
[ERROR] ‚Ä¶/src/test/java/com/example/app/ApplicationModularityTests.java:[24,29] com.example.app.order.OrderRepository is not public in com.example.app.order; cannot be accessed from outside package
----

. Resolve the compilation error by making `OrderRepository` public.

. Re-run `ApplicationModularityTests` to validate that the compilation now succeeds.

ifdef::educates[]
[source,section:begin]
----
title: "Expand for clickable instructions"
----
[source, editor:select-matching-text]
----
title: "Make OrderRepository public"
file: ~/exercises/src/main/java/com/example/app/order/OrderRepository.java
text: class OrderRepository
cascade: true
description: public class OrderRepository
----
[source, editor:replace-text-selection]
----
file: ~/exercises/src/main/java/com/example/app/order/OrderRepository.java
text: public class OrderRepository
hidden: true
----
[source, terminal:execute]
----
title: ‚ÄúRun test‚Äù
command: mvnw test
----
[source,section:end]
----
----
endif::[]

Examine the output. Both components should now be marked as public.
[source, text]
----
‚Ä¶
# Order
> Logical name: order
> Base package: com.example.app.order
> Direct module dependencies: none
> Spring beans:
  + ‚Ä¶.OrderManagement
  + ‚Ä¶.OrderRepository
----

While this solution works, it exposes `OrderRepository` to access from anywhere in the application.
This is a clear indication that Java visibility modifiers are insufficient to protect bounded contexts within a monolithic code base.

Let's explore how Spring Modulith offers finer-grain control over the visibility of this class.

[[module-design.control-visibility.nested-packages]]
== üë£ Hiding components in nested packages

. Introduce a package named `order.persistence` and move `OrderRepository` to that package.

. Re-run `ApplicationModularityTests`.

ifdef::educates[]
[source,section:begin]
----
title: "Expand for clickable instructions"
----
[source, terminal:execute]
----
prefix: Editor
title: "Move OrderRepository to subpackage"
command: |
    # Create directory, move file, update package declaration
	mkdir -p src/main/java/com/example/app/order/persistence && \
    mv src/main/java/com/example/app/order/OrderRepository.java src/main/java/com/example/app/order/persistence/ && \
	sed -i "s/package com\.example\.app\.order;/package com\.example\.app\.order\.persistence;/" src/main/java/com/example/app/order/persistence/OrderRepository.java
    # Update the import statement in classes that reference OrderRepository
    sed -i "s/import com\.example\.app\.order.\OrderRepository;/import com\.example\.app\.order\.persistence.\OrderRepository;/" src/test/java/com/example/app/ApplicationModularityTests.java && \
    sed -i "s/@Component/import com\.example\.app\.order\.persistence.\OrderRepository;\n\n@Component/" src/main/java/com/example/app/order/OrderManagement.java
session: 2
cascade: true
description: |
    Click on this action to move and refactor OrderRepository.
----
[source, terminal:execute]
----
command: clear
session: 2
cascade: true
hidden: true
----
[source, editor:execute-command]
----
command: workbench.action.closeActiveEditor
cascade: true
hidden: true
----
[source, editor:open-file]
----
hidden: true
file: ~/exercises/src/main/java/com/example/app/order/persistence/OrderRepository.java
----
[source, terminal:execute]
----
title: ‚ÄúRun test‚Äù
command: mvnw test
----
[source,section:end]
----
----
endif::[]

Examine the output. Notice that simply moving `OrderRepository` out of the API package of the `order` module and into a sub-package is sufficient for Spring Modulith to identify it as an internal component.
[source, text]
----
# Order
> Logical name: order
> Base package: com.example.app.order
> Direct module dependencies: none
> Spring beans:
  + ‚Ä¶.OrderManagement
  o ‚Ä¶.persistence.OrderRepository
----

. Next, open the main `Application` class and add a reference to `OrderRepository`. For example, you can add a constructor that takes an `OrderRepository` as an argument.
ifndef::educates[]
+
[source, java]
----
@SpringBootApplication
class Application {

	Application(OrderRepository repository) {}
}
----
endif::[]

. Re-run `ApplicationModularityTests`.

ifdef::educates[]
[source,section:begin]
----
title: "Expand for clickable instructions"
----
[source, editor:select-matching-text]
----
title: "Add a reference to OrderRepository in Application"
file: ~/exercises/src/main/java/com/example/app/Application.java
text: "@SpringBootApplication"
before: 0
after: 1
cascade: true
description: |
    @SpringBootApplication
    public class Application {

        Application(OrderRepository repository) {}
----
[source, editor:replace-text-selection]
----
hidden: true
file: ~/exercises/src/main/java/com/example/app/Application.java
text: |
    import com.example.app.order.persistence.OrderRepository;

    @SpringBootApplication
    public class Application {

        Application(OrderRepository repository) {}
----
[source, terminal:execute]
----
title: ‚ÄúRun test‚Äù
command: mvnw test
----
[source,section:end]
----
----
endif::[]

Examine the output. If you were expecting compilation error because `OrderRepository` is considered internal to the `order` module, you might be surprised to see that the code still compiles successfully.


This example highlights the inability of the Java compiler to recognize or enforce the scopes of visibility defined by Spring Modulith.
The Java compiler recognizes `OrderRepository` as public, but it is not aware that it should be accessible publicly only within the `order` module, not outside of it.


To compensate for this limitation, Spring Modulith provides a `verify()` method that will execute the additional checks.

. Add a call to the `verify()` method in `ApplicationModularityTests`.

ifndef::educates[]
+
[source, java]
----
class ApplicationModularityTests {

	OrderRepository orderRepository;

	@Test
	void bootstrapsApplicationModules() {

		var modules = ApplicationModules.of(Application.class).verify();

		System.out.println(modules);
	}
}
----
endif::[]

. Re-run `ApplicationModularityTests` to validate that the compilation now succeeds.

ifdef::educates[]
[source,section:begin]
----
title: "Expand for clickable instructions"
----
[source, editor:select-matching-text]
----
title: "Add a call to ApplicationModules verify() method to ApplicationModularityTests"
file: ~/exercises/src/test/java/com/example/app/ApplicationModularityTests.java
text: "ApplicationModules.of(Application.class);"
cascade: true
description: |
    var modules = ApplicationModules.of(Application.class).verify();
----
[source, editor:replace-text-selection]
----
hidden: true
file: ~/exercises/src/test/java/com/example/app/ApplicationModularityTests.java
text: |
    ApplicationModules.of(Application.class).verify();
----
[source, terminal:execute]
----
title: ‚ÄúRun test‚Äù
command: mvnw test
----
[source,section:end]
----
----
endif::[]

Examine the output. You should see that the test now fails as the reference to an application module *internal* type is invalid.
[source, java]
----
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running com.example.app.ApplicationModularityTests
02:07:18.909 [main] INFO com.tngtech.archunit.core.PluginLoader -- Detected Java version 21.0.1
[ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.728 s <<< FAILURE! -- in com.example.app.ApplicationModularityTests
[ERROR] com.example.app.ApplicationModularityTests.bootstrapsApplicationModules -- Time elapsed: 0.714 s <<< ERROR!
org.springframework.modulith.core.Violations:
- Module 'root:com.example.app' depends on non-exposed type com.example.app.order.persistence.OrderRepository within module 'order'!
Application declares constructor Application(OrderRepository) in (Application.java:0)
- Module 'root:com.example.app' depends on non-exposed type com.example.app.order.persistence.OrderRepository within module 'order'!
Constructor <com.example.app.Application.<init>(com.example.app.order.persistence.OrderRepository)> has parameter of type <com.example.app.order.persistence.OrderRepository> in (Application.java:0)
...
----

[[module-design.control-visibility.named-interfaces]]
== üë£ Named interfaces

Named interfaces provide a flexible way of selectively exposing additional types in an application modules API.

. Annotate `OrderRepository` with `@NamedInterface`.

ifndef::educates[]
+
[source, java]
----
import org.springframework.stereotype.Repository;

@Repository
class OrderRepository {}
----
endif::[]

. Re-run `ApplicationModularityTests`

ifdef::educates[]
[source, section:begin]
----
title: "Expand for clickable instructions"
----
[source, editor:select-matching-text]
----
title: "Annotate OrderRepository with @NamedInterface"
file: ~/exercises/src/main/java/com/example/app/order/persistence/OrderRepository.java
text: "@Repository"
before: 1
after: 0
cascade: true
description: |
	import org.springframework.stereotype.Repository;
    import org.springframework.stereotype.NamedInterface;

    @Repository
    @NamedInterface
	public class OrderRepository {}
----
[source, editor:replace-text-selection]
----
hidden: true
file: ~/exercises/src/main/java/com/example/app/order/persistence/OrderRepository.java
text: |
    import org.springframework.modulith.NamedInterface;

    @Repository
    @NamedInterface
----
[source, terminal:execute]
----
title: "Run test"
command: mvnw test
----
[source, section:end]
----
----
endif::[]

Examine the output and note the following changes:

* The output lists two named interfaces.
The _unnamed_ interface contains all types contained in the application module's base API package.
This particular interface always exists implicitly.
Furthermore, a second named interface _persistence_ exists.
It's a result of us annotating `OrderRepository` with `@NamedInterface` and named by the local package name containing the annotated type.
* `OrderRepository` being assigned to a named interface now makes it a part of the overall application module API (note the `+` sign in front of its Spring bean listing).
That in turn causes the verification to not fail anymore.

[source, text]
----
# Order
> Logical name: order
> Base package: com.example.app.order
> Named interfaces:
  + NamedInterface: name=<<UNNAMED>>, types=[ c.e.a.o.OrderManagement ]
  + NamedInterface: name=persistence, types=[ c.e.a.o.p.OrderRepository ]
> Direct module dependencies: none
> Spring beans:
  + ‚Ä¶.OrderManagement
  + ‚Ä¶.persistence.OrderRepository
----

[[module-design.control-visibility.cleanup]]
== üë£ Cleanup

Reverse the last two changes.
While they helped illustrate Spring Modulith features, exposing `OrderRepository` outside of the `order` module and referencing it from the main `Application` class aren't useful or necessary configurations.

[source, editor:select-matching-text]
----
title: "Remove annotation of OrderRepository as @NamedInterface"
file: ~/exercises/src/main/java/com/example/app/order/persistence/OrderRepository.java
text: "@NamedInterface"
before: 3
after: 0
cascade: true
description: |
	import org.springframework.stereotype.Repository;

    @Repository
	public class OrderRepository {}
----
[source, editor:replace-text-selection]
----
hidden: true
file: ~/exercises/src/main/java/com/example/app/order/persistence/OrderRepository.java
text: |

    @Repository
----

[source, editor:select-matching-text]
----
title: "Remove reference to OrderRepository in Application class"
file: ~/exercises/src/main/java/com/example/app/Application.java
text: "@SpringBootApplication"
before: 2
after: 9
cascade: true
description: |
    @SpringBootApplication
    public class Application {

        public static void main(String... args) throws Exception {
            SpringApplication.run(Application.class, args);
        }
    }
----
[source, editor:replace-text-selection]
----
hidden: true
file: ~/exercises/src/main/java/com/example/app/Application.java
text: |
    @SpringBootApplication
    public class Application {

        public static void main(String... args) throws Exception {
            SpringApplication.run(Application.class, args);
        }
    }
----

In the next lab,
ifndef::educates[]
xref:204-lab-explicit-dependencies.adoc[module-design.explicit-dependencies],
endif::[]
we will learn how to use named interfaces to explicitly control allowed dependencies between application modules.
