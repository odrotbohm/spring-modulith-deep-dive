[[module-design]]
= Designing Application Modules
:tabsize: 2
:source: complete/src/main/java/com/example/app
:test-source: complete/src/test/java/com/example/app

ifndef::educates[]
include::201-article-fundamentals-of-application-module-design.adoc[leveloffset=+1]
include::202-lab-application-module-visibility.adoc[leveloffset=+1]
include::203-lab-application-module-relationships.adoc[leveloffset=+1]
endif::[]

ifdef::educates[]
[source, terminal:execute-all]
----
command: cd ~/exercises && clear
autostart: true
hidden: true
----

[source, dashboard:reload-dashboard]
----
name: Editor
autostart: true
hidden: true
----
endif::[]

[[module-design.module-api-defaults]]
== 📖 Fundamentals of Application Module design

- Application module's base package considered its API package.
- Any nested package is considered module-internal. Code residing in it is not allowed to be accessed by other application modules.

[[module-design.control-visibility]]
== 🧑‍💻 Using Application Modules to control visibility

[[module-design.control-visibility.objectives]]
=== 🎯 Objectives

You'll learn how to…

* … add components and events to the module and control their visibility
* … verify foreign application modules cannot access internal components

[[module-design.control-visibility.package-protected-types]]
=== 👣 Hiding application module internals by using the package scope

Add an `OrderRepository` class in default scope to the `order` package

ifndef::educates[]
[source, java]
----
import org.springframework.stereotype.Repository;

@Repository
class OrderRepository {}
----
endif::[]

ifdef::educates[]
[source, editor:append-lines-to-file]
----
file: ~/exercises/src/main/java/com/example/app/order/OrderRepository.java
text: |
	package com.example.app.order;

	import org.springframework.stereotype.Repository;

	@Repository
	class OrderRepository {}
----
endif::[]

In `OrderManagement`, create a Spring bean reference to the new `OrderRepository` class you just created.

ifndef::educates[]
[source, java]
----
include::{source}/order/OrderManagement.java[tags=class]
----
endif::[]

ifdef::educates[]
[source, editor:select-matching-text]
----
file: ~/exercises/src/main/java/com/example/app/order/OrderManagement.java
text: "public class OrderManagement {}"
before: 2
after: 0
----
endif::[]

ifdef::educates[]
[source, editor:replace-text-selection]
----
file: ~/exercises/src/main/java/com/example/app/order/OrderManagement.java
text: |
	import lombok.RequiredArgsConstructor;

	@Component
	@RequiredArgsConstructor
	public class OrderManagement {

		private final OrderRepository repository;
	}
----
endif::[]

ifndef::educates[]
Re-run `ApplicationModularityTests`.
endif::[]
ifdef::educates[]
Run the `ApplicationModularityTests` you learned about in the previous lab.

[source, terminal:execute]
----
command: mvnw test
----
endif::[]
Recall that `OrderManagement` is public and is labeled with `+`.
In contrast, `OrderRepository` is detected as an *internal* module component and labeled accordingly with `o`).

[source, bash]
----
…
# Order
> Logical name: order
> Base package: com.example.app.order
> Direct module dependencies: none
> Spring beans:
  + ….OrderManagement
  o ….OrderRepository
----

To highlight the impact of Java visibility modifiers—`public`, `default/package-private`, etc—on the accessibility of classes from different packages, try adding a reference to `OrderRepository` from `ApplicationModularityTests` and see how the compiler prevents that.

ifdef::educates[]
[source, editor:select-matching-text]
----
file: ~/exercises/src/test/java/com/example/app/ApplicationModularityTests.java

text: "class ApplicationModularityTests {"
before: 0
after: 0
----

[source, editor:replace-text-selection]
----
file: ~/exercises/src/test/java/com/example/app/ApplicationModularityTests.java
text: |
	import com.example.app.order.OrderRepository;

	class ApplicationModularityTests {

		OrderRepository orderRepository;
----

[source, terminal:execute]
----
command: mvnw test
----
endif::[]

You should see a compilation error since `OrderRepository` can only be accessed from within the same package.

[source, bash]
----
[INFO] -------------------------------------------------------------
[ERROR] COMPILATION ERROR :
[INFO] -------------------------------------------------------------
[ERROR] /home/eduk8s/exercises/20-designing-application-modules/initial/src/test/java/com/example/app/ApplicationModularityTests.java:[24,29] com.example.app.order.OrderRepository is not public in com.example.app.order; cannot be accessed from outside package
----

The solution is to make `OrderRepository` public.

ifdef::educates[]
[source, editor:select-matching-text]
----
file: ~/exercises/src/main/java/com/example/app/order/OrderRepository.java
text: class OrderRepository
----

[source, editor:replace-text-selection]
----
file: ~/exercises/src/main/java/com/example/app/order/OrderRepository.java
text: public class OrderRepository
----
endif::[]

Re-run `ApplicationModularityTests` to validate that the compilation now succeeds.

ifdef::educates[]
[source, terminal:execute]
----
command: mvnw test
----
endif::[]

Both components are marked as public.
[source, bash]
----
# Order
> Logical name: order
> Base package: com.example.app.order
> Direct module dependencies: none
> Spring beans:
  + ….OrderManagement
  + ….OrderRepository
----

While this solution works, it exposes `OrderRepository` to access from anywhere in the  application.
This is a clear indication that Java visibility modifiers are insufficient to protect bounded contexts within a monolithic code base.

Let's explore how Spring Modulith can help us exert finer-grain control over the visibility of this class.

[[module-design.control-visibility.nested-packages]]
=== 👣 Hiding components in nested packages
Introduce a package named `order.persistence` and move `OrderRepository` to that package.

ifdef::educates[]
[source, terminal:execute]
----
command: |
	mkdir -p src/main/java/com/example/app/order/persistence
	mv src/main/java/com/example/app/order/OrderRepository.java src/main/java/com/example/app/order/persistence/
	sed -i "s/package com\.example\.app\.order;/package com\.example\.app\.order\.persistence;/" src/main/java/com/example/app/order/persistence/OrderRepository.java
---

You also need to update the import statement in each of the classes that reference `OrderRepository`.
[source, terminal:execute]
----
	sed -i "s/import com\.example\.app\.order.\OrderRepository;/import com\.example\.app\.order\.persistence.\OrderRepository;/" src/test/java/com/example/app/ApplicationModularityTests.java
	sed -i "s/@Component/import com\.example\.app\.order\.persistence.\OrderRepository;\n\n@Component/" src/main/java/com/example/app/order/OrderManagement.java
----
endif::[]

Re-run `ApplicationModularityTests`.

ifdef::educates[]
[source, terminal:execute]
----
command: mvnw test
----
endif::[]

Removing `OrderRepository` from the API package of the `order` module by simply relocating the class to a subpackage is sufficient for Spring Modulith to recognize it as an internal component.

[source, bash]
----
# Order
> Logical name: order
> Base package: com.example.app.order
> Direct module dependencies: none
> Spring beans:
  + ….OrderManagement
  o ….persistence.OrderRepository
----

////
[[module-design.control-visibility.named-interfaces]]
=== 👣 Steps -- Named interfaces

- Annotate package with `@NamedInterface`
- Discuss output
- Add type in root package, annotated -> also assigned to that NI
////

[[module-design.relationships]]
== 🧑‍💻 Establishing relationships between modules

[[module-design.relationships.objectives]]
=== 🎯 Objectives

You'll learn how to…

* … establish relationships between modules via Spring bean references
* … detect invalid dependencies via a JUnit-based architectural fitness function

[[module-design.relationships.managing-type-relationships]]
=== 👣 Managing type relationships

- Introduce inventory
- Create `Inventory`
- Add constructor argument of type `OrderManagement`
- add verify()
- Run test -> green
- Change constructor argument to `OrderRepository` -> red as it's an internal component
